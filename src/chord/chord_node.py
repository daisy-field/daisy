"""    Class for Federated Peer that implements a fault-tolerant version of the Chord Protocol    Author: Lotta Fejzula    Modified: 15.09.23"""import loggingfrom typing import Selffrom src.communication.message_stream import StreamEndpoint# TODO implement recv message handler -> ask fabian again, still confused# TODO socket select# TODO logging# TODO Boostrappingclass Chordnode:    """    Class for Chordnodes.    """    _id: int    _name: str    _addr: tuple[str, int]    _finger_table: dict[int: [tuple[str, int], StreamEndpoint]]    _successor: tuple[int, tuple[str, int]]    _successor_endpoint: StreamEndpoint    _predecessor: tuple[int, tuple[str, int]]    _predecessor_endpoint: StreamEndpoint    _node_endpoints: []    def __init__(self, node_id: int = 0, name: str = "unnamed", addr: tuple[str, int] = ("127.0.0.1", 8080),                 finger_table: dict[int: [tuple[str, int], StreamEndpoint]] = None,                 successor: tuple[int, tuple[str, int]] = Self,                 predecessor: tuple[int, tuple[str, int]] = None,                 _node_endpoints: StreamEndpoint = None):        """        Creates a new Chord Peer.        :param node_id: Name of endpoint for logging purposes.        :param name: Name of Peer.        :param addr: Address of Peer.        :param finger_table: Dictionary of other nodes across the chord ring, known to this node.        :param successor: Successor of node on Chord Ring, initialized as self        :param predecessor: Predecessor of node on Chord Ring, initialized as None        """        self._id = node_id        self._name = name        self._addr = addr        self._finger_table = finger_table  # starts at 1        self._successor = successor  # init to None, set at join to chord ring        self._predecessor = predecessor        self._node_endpoints = _node_endpoints    def send_open_chord(self):        # open accepting endpoint for joining nodes        self._node_endpoints = StreamEndpoint(name=f"Acceptor-Public-{Chordnode._name}", addr=self._addr,                                              acceptor=True, multithreading=False, buffer_size=10000)        self._node_endpoints.start()        while True:            try:                print(f"{self._name}-{self._node_endpoints.start().receive(5)}")            except TimeoutError:                print(f"{self._name}-Hello darkness my old friend...")    def send_join_chord(self, remote_addr: tuple[str, int]):        """        Sends join request to a node in an existing Chordring.        :param remote_addr: Address of bootstrap node        """        # send join message to bootstrap node        join_chord_message = Chordmessage(message_type="join", sender_id=self._id,                                          sender_addr=self._addr, payload={"id": self._id,                                                                           "address": self._addr})        endpoint = StreamEndpoint(name=f"Join-Endpoint-{self._id}", addr=self._addr,                                  remote_addr=remote_addr, acceptor=False, multithreading=False,                                  buffer_size=10000)        endpoint.start()        endpoint.send(join_chord_message)        endpoint.stop()  # shutdown?        # TODO when will succ be set? bc async    def send_notify(self, remote_id: int, remote_addr: tuple[str, int]):        notify_message = Chordmessage(message_type="notify", sender_id=self._id, sender_addr=self._addr,                                      payload={"predecessor": self._predecessor})        node_in_ft = self._finger_table.get(remote_id)        if node_in_ft is not None:            node_in_ft.send(notify_message)        else:            endpoint = StreamEndpoint(name=f"Join-Endpoint-{self._id}", addr=self._addr,                                      remote_addr=remote_addr, acceptor=False, multithreading=False,                                      buffer_size=10000)            endpoint.start()            endpoint.send(notify_message)    def send_stabilize(self):        if self._successor is None:            pass  # todo except        stabilize_message = Chordmessage(message_type="stabilize", sender_id=self._id, sender_addr=self._addr,                                         payload={"id": self._id, "address": self._addr})        self._successor_endpoint.send(stabilize_message)    def fix_fingertable(self):        """Function to keep fingertables current with nodes joining and leaving the chordring. Should be called        periodically by each node.        """        for i in range(self._finger_table.len()):            self.send_find_successor(self._addr, self._id + 2 ** i)    def send_find_successor(self, remote_addr: tuple[str, int], find_succ_id: int):        """Function to find successor of node with chord id find_succ_id. Message will be relayed along the cordring        until the successor is found. In the end, the chord id and chord address of the found node will be sent back        directly to the node who initially send the request.        :param remote_addr: chord address of node who initially sent the find_successor request        :param find_succ_id: chord id of node whose successor should be found        """        # todo beautify        # todo usage        if (self._id < self._successor[0]) & (find_succ_id not in range(self._successor[0], self._id + 1)) \                or (                find_succ_id in range(self._id, self._successor[0] + 1)):  # this should work, stop thinking about it!            # add successor info to chordmessage            succ_found_msg = Chordmessage(message_type="find_successor_success", sender_id=self._id,                                          sender_addr=self._addr, payload={"successor": self._successor})            # todo check whether ep to find_succ_id exists instead            node_in_ft = self._finger_table.get(find_succ_id)            if node_in_ft is not None:                node_in_ft.send(succ_found_msg)            else:                endpoint = StreamEndpoint(name=f"Sender-find_successor-id:{find_succ_id}", addr=self._addr,                                          remote_addr=remote_addr, acceptor=False, multithreading=False,                                          buffer_size=10000)                endpoint.start()                endpoint.send(succ_found_msg)                endpoint.stop(shutdown=True)            return        if find_succ_id in range(self._predecessor[0], self._id):  # return self if new node is predecessor            succ_found_msg = Chordmessage(message_type="find_successor_success", sender_id=self._id,                                          sender_addr=self._addr, payload={"successor_id": self._id,                                                                           "successor_addr": self._addr})            # todo check whether ep to find_succ_id exists instead            node_in_ft = self._finger_table.get(find_succ_id)            if node_in_ft is not None:                node_in_ft.send(succ_found_msg)            else:                endpoint = StreamEndpoint(name=f"Sender-find_successor-id:{find_succ_id}", addr=self._addr,                                          remote_addr=remote_addr, acceptor=False, multithreading=False,                                          buffer_size=10000)                endpoint.start()                endpoint.send(succ_found_msg)                endpoint.stop(shutdown=True)                return        # if IDK -> ask node that closest precedes find_succ_id        for finger in self._finger_table.keys():            if self._id < self._finger_table.get(finger) < find_succ_id:                self._finger_table.get(finger).send(                    Chordmessage(message_type="find_successor", sender_id=self._id, sender_addr=self._addr,                                 payload={"find_id": find_succ_id, "reply_addr": remote_addr}))                break    def chord_receive_message_handler(self):        while True:            break        # while True:        # each endpoint recv        # switch case over message types        # call corresponding answer methods or set values        # handle join        # handle find_successor        # handle find_successor_success        # handle stabilize        # handle notify        pass    def recv_join(self):        passclass Chordmessage:    """    Class for Chord messages. Message_type can be chosen freely, but should be documented. Sender_id and Sender_addr    will be set to the id and addr of the Node who sends the message. Payload can contain anything that should be    processed by the receiving node in accordance to the message type.    """    _message_type: str    # find_successor_success, find_successor    # stabilize    # notify    # join    _sender_id: int    _sender_addr: tuple[str, int]    _payload: dict    def __init__(self, message_type: str = "unspecified", sender_id: int = -1, sender_addr: tuple[str, int] = None,                 payload: dict = None):        """        Creates a new Chordmessage Object.        :param message_type: denotes how the message will be processed at receiving endpoint        :param sender_id: chord id of sending node        :param sender_addr: chord address of sending node, used for replying        :param payload: key-value pairs with the contents of the message        """        self._message_type = message_type        self._sender_id = sender_id        self._sender_addr = sender_addr        self._payload = payloadif __name__ == "__main__":    logging.basicConfig(format="%(asctime)s %(levelname)-8s %(name)-10s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",                        level=logging.INFO)    pass