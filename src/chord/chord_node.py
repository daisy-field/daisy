"""    Class for Federated Peer that implements a fault-tolerant version of the Chord Protocol    Author: Lotta Fejzula    Modified: 15.09.23"""import loggingfrom enum import Enumfrom typing import Selfimport numpy as npfrom src.communication.message_stream import StreamEndpointfrom src.communication.message_stream import ep_select# TODO implement recv message handler -> ask fabian again, still confused# TODO socket select# TODO logging# TODO Boostrappingclass Chordnode:    """    Class for Chordnodes.    """    _id: int    _name: str  # for debugging    _addr: tuple[str, int]    _finger_table: dict[int: [tuple[str, int], StreamEndpoint]]    _successor: tuple[int, tuple[str, int]]    _successor_endpoint: StreamEndpoint    _predecessor: tuple[int, tuple[str, int]]    _predecessor_endpoint: StreamEndpoint    _node_endpoints: list[StreamEndpoint]    def __init__(self, node_id: int = 0, name: str = "unnamed", addr: tuple[str, int] = ("127.0.0.1", 8080),                 finger_table: dict[int: [tuple[str, int], StreamEndpoint]] = None,                 successor: tuple[int, tuple[str, int]] = Self,                 predecessor: tuple[int, tuple[str, int]] = None,                 _node_endpoints: [] = None):        """        Creates a new Chord Peer.        :param node_id: Name of endpoint for logging purposes.        :param name: Name of Peer.        :param addr: Address of Peer.        :param finger_table: Dictionary of other nodes across the chord ring, known to this node.        :param successor: Successor of node on Chord Ring, initialized as self        :param predecessor: Predecessor of node on Chord Ring, initialized as None        """        self._id = node_id        self._name = name        self._addr = addr        self._finger_table = finger_table  # starts at 1        self._successor = successor  # init to None, set at join to chord ring        self._predecessor = predecessor        self._node_endpoints = _node_endpoints    def send_join_chord(self, remote_addr: tuple[str, int] = None):        """        Sends join request to a node in an existing Chordring.        :param remote_addr: Address of bootstrap node        """        # send join message to bootstrap node        if remote_addr is not None:            join_chord_message = Chordmessage(message_type=MessageType.join, sender_id=self._id,                                              sender_addr=self._addr, payload={"id": self._id,                                                                               "address": self._addr})            endpoint = StreamEndpoint(name=f"Join-Endpoint-{self._id}", addr=self._addr,                                      remote_addr=remote_addr, acceptor=False, multithreading=False,                                      buffer_size=10000)            endpoint.start()            endpoint.send(join_chord_message)            endpoint.stop(shutdown=True)  # shutdown?        else:            self.open_endpoints()    def send_notify(self, remote_id: int, remote_addr: tuple[str, int]):        notify_message = Chordmessage(message_type=MessageType.notify, sender_id=self._id, sender_addr=self._addr,                                      payload={"predecessor": self._predecessor})        node_in_ft = self._finger_table.get(remote_id)        if node_in_ft is not None:            node_in_ft.send(notify_message)        else:            endpoint = StreamEndpoint(name=f"Join-Endpoint-{self._id}", addr=self._addr,                                      remote_addr=remote_addr, acceptor=False, multithreading=False,                                      buffer_size=10000)            endpoint.start()            endpoint.send(notify_message)    def send_stabilize(self):        if self._successor is None:            pass  # todo except        stabilize_message = Chordmessage(message_type=MessageType.stabilize, sender_id=self._id, sender_addr=self._addr,                                         payload={"id": self._id, "address": self._addr})        self._successor_endpoint.send(stabilize_message)    def fix_fingertable(self):        """Function to keep fingertables current with nodes joining and leaving the chordring. Should be called        periodically by each node.        """        for i in range(self._finger_table.len()):            # todo wont work like this            self.send_find_succ_of_node(self._addr, self._id + 2 ** i)    def send_find_succ_of_node(self, remote_addr: tuple[str, int], node_id: int):        # this should work, stop thinking about it!        """Function to find successor of node with chord id find_succ_id. Message will be relayed along the cordring        until the successor is found. In the end, the chord id and chord address of the found node will be sent back        directly to the node who initially send the request.        :param remote_addr: chord address of node who initially sent the find_successor request        :param node_id: chord id of node whose successor should be found        """        if (self._id < self._successor[0]) & (node_id not in range(self._successor[0], self._id + 1)) \                or (                node_id in range(self._id, self._successor[0] + 1)):            # add successor info to chordmessage            succ_found_msg = Chordmessage(message_type=MessageType.find_successor_success, sender_id=self._id,                                          sender_addr=self._addr, payload={"successor": self._successor})            # todo check whether ep to find_succ_id exists instead here and            node_in_ft = self._finger_table.get(node_id)            if node_in_ft is not None:                node_in_ft.send(succ_found_msg)            else:                endpoint = StreamEndpoint(name=f"Sender-find_successor-id:{node_id}", addr=self._addr,                                          remote_addr=remote_addr, acceptor=False, multithreading=False,                                          buffer_size=10000)                endpoint.start()                endpoint.send(succ_found_msg)                endpoint.stop(shutdown=True)            return        if node_id in range(self._predecessor[0], self._id):  # return self if new node is predecessor            succ_found_msg = Chordmessage(message_type=MessageType.find_successor_success, sender_id=self._id,                                          sender_addr=self._addr, payload={"successor_id": self._id,                                                                           "successor_addr": self._addr})            # here            node_in_ft = self._finger_table.get(node_id)            if node_in_ft is not None:                node_in_ft.send(succ_found_msg)            else:                endpoint = StreamEndpoint(name=f"Sender-find_successor-id:{node_id}", addr=self._addr,                                          remote_addr=remote_addr, acceptor=False, multithreading=False,                                          buffer_size=10000)                endpoint.start()                endpoint.send(succ_found_msg)                endpoint.stop(shutdown=True)                return        # if IDK -> ask node that closest precedes find_succ_id        for finger in self._finger_table.keys():            if self._id < self._finger_table.get(finger) < node_id:                self._finger_table.get(finger).send(                    Chordmessage(message_type=MessageType.find_successor, sender_id=self._id, sender_addr=self._addr,                                 payload={"find_id": node_id, "reply_addr": remote_addr}))                break    def process_join(self):        # todo implement        pass    def process_notify(self):        # todo implement        pass    def process_stabilize(self):        # todo implement        pass    def process_find_succ(self):        # todo implement        pass    def open_endpoints(self, count: int = 1):        for i in range(count):            self._node_endpoints.append(                StreamEndpoint(name=f"{self._name}-{self._id}-recv-{i}-{np.random.randint(0, 100)}", addr=self._addr,                               acceptor=True, multithreading=False, buffer_size=10000))    def select_endpoints(self):        return ep_select(self._node_endpoints)    def close_endpoints(self):        pass    def node_message_handler(self):        # todo implement        while True:            read_eps, write_eps = self.select_endpoints()            break        # while True:        # each endpoint recv        # switch case over message types        # call corresponding answer methods or set values        # handle join        # handle find_successor        # handle find_successor_success        # handle stabilize        # handle notify        passclass MessageType(Enum):    join = 1    find_successor_success = 2    find_successor = 3    stabilize = 4    notify = 5class Chordmessage:    """    Class for Chord messages. Message_type can be chosen freely, but should be documented. Sender_id and Sender_addr    will be set to the id and addr of the Node who sends the message. Payload can contain anything that should be    processed by the receiving node in accordance to the message type.    """    _message_type: MessageType    _sender_id: int    _sender_addr: tuple[str, int]    _payload: dict    def __init__(self, message_type: MessageType, sender_id: int = -1, sender_addr: tuple[str, int] = None,                 payload: dict = None):        """        Creates a new Chordmessage Object.        :param message_type: denotes how the message will be processed at receiving endpoint        :param sender_id: chord id of sending node        :param sender_addr: chord address of sending node, used for replying        :param payload: key-value pairs with the contents of the message        """        self._message_type = message_type        self._sender_id = sender_id        self._sender_addr = sender_addr        self._payload = payloadif __name__ == "__main__":    logging.basicConfig(format="%(asctime)s %(levelname)-8s %(name)-10s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",                        level=logging.INFO)    pass