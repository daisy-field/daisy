<!--
  ~ Copyright (C) 2024 DAI-Labor and others
  ~
  ~ This Source Code Form is subject to the terms of the Mozilla Public
  ~ License, v. 2.0. If a copy of the MPL was not distributed with this
  ~ file, You can obtain one at https://mozilla.org/MPL/2.0/.
  -->
{% extends "./base.html" %}
{% block body_theme %}
{% if dark_theme %}
"sb-nav-fixed bg-dark"
{% else %}
"sb-nav-fixed"
{% endif %}
{% endblock %}

{% block footer_theme %}
{% if dark_theme %}
"py-4 bg-dark mt-auto"
{% else %}
"py-4 mt-auto"
{% endif %}
{% endblock %}

{% block navbar_theme %}
{% if dark_theme %}
"sb-sidenav accordion sb-sidenav-dark"
{% else %}
"sb-sidenav accordion sb-sidenav-light"
{% endif %}
{% endblock %}

{% block main %}



<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>


<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@0.7.3"></script>

<script type="text/javascript" >
//TODO: remove datapoints, improve initial loading, reloading maybe loading in batches
//try to merge nodes with similar times 

  window.onload = function() {

        var nodes = []
        var times = []


        const ctx = document.getElementById('lineChart').getContext('2d');
                    const chartData = {
                        labels: [], // Time data
                        datasets: []
                    };

        const lineChart = new Chart(ctx, {
                        type: 'line',
                        data: chartData,

                        options: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                },

                            },
                            layout: {
                                padding: 50
                            },
                            devicePixelRatio: 1.5,
                            responsive: true,
                            tooltip: {
        mode: 'nearest',
                                intersect:true,
    },        animation: false,

                            hover: {
                                mode: 'nearest',
                                intersect: true
                            },
                            scales: {
                                xAxes: [{
                                    display: true,
                                    scaleLabel: {
                                        display: true,
                                    },
                                    ticks:{
                                        autoSkip: true,
                                        maxTicksLimit: 20
                                    },
                                }],
                                yAxes: [{
                                    display: true,
                                    scaleLabel: {
                                        display: true,
                                    }
                                }],

                            },
                            {%if interpolation == True %}
                             elements: {
                                 point: {
                                     radius: 0
                                 }
                             },
                            {%endif%}
                            plugins: {
                                zoom: {
                                    zoom: {
                                        enabled: false,
                                        mode: "y",
                                        speed: 0.1,
                                        // sensitivity: 0.1,
                                    }

                                }
                            }

                        },

                    });

        function getRandomColor() {
                        const letters = '0123456789ABCDEF';
                        let color = '#';
                        for (let i = 0; i < 6; i++) {
                            color += letters[Math.floor(Math.random() * 16)];
                        }
                        return color;
                    }

        document.getElementById('exportJSON').addEventListener('click', function () {
            //const selectedNodes = getSelectedNodes();
             $.ajax({
                 url: "http://127.0.0.1:8000/metrics/",
                type: "GET",
                dataType: "json",
                success: (response) => {
                    const jsonStr = JSON.stringify(response);
                    const blob = new Blob([jsonStr], { type: "application/json" });
                    const link = document.createElement("a");
                    link.download = "metrics.json";
                    link.href = URL.createObjectURL(blob);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                }
             })})


        document.getElementById('exportImage').addEventListener('click', function () {
            // Code to export as image goes here
            console.log("Export as Image");
            console.log(lineChart.toBase64Image());
            var a = document.createElement('a');
            a.href = lineChart.toBase64Image();
            a.download = '{{ metric_name}}.png';
            a.click();
        })

        document.getElementById('exportCSV').addEventListener('click', function () {
            console.log("Export CSV");

            downloadCSV({
                filename: "chart-data.csv",
                chart: lineChart
            })
            // Code to download/export CSV can be added here
        });
        function convertChartDataToCSV(args) {
            let result, columnDelimiter, lineDelimiter, labels, data;

            data = args.data.data || null;
            if (data == null || !data.length) {
                return null;
            }

            labels = args.labels || null;
            if (labels == null || !labels.length) {
                return null;
            }

            columnDelimiter = args.columnDelimiter || ',';
            lineDelimiter = args.lineDelimiter || '\n';

            result = '' + columnDelimiter;
            result += labels.join(columnDelimiter);
            result += lineDelimiter;

            //result += args.data.label.toString();

            for (let i = 0; i < data.length; i++) {
                result += columnDelimiter;
                result += data[i];
            }
            result += lineDelimiter;

            return result;
        }

function downloadCSV(args) {
  var data, filename, link;
  var csv = "";
  for (var i = 0; i < lineChart.data.datasets.length; i++) {
    csv += convertChartDataToCSV({
      data: lineChart.data.datasets[i],
      labels: chartData.labels
    });
  }
  if (csv == null) return;
  console.log(csv);

  filename = args.filename || 'chart-data.csv';
  if (!csv.match(/^data:text\/csv/i)) {
    csv = 'data:text/csv;charset=utf-8,' + csv;
  }

  // not sure if anything below this comment works
  data = encodeURI(csv);
  link = document.createElement('a');
  link.setAttribute('href', data);
  link.setAttribute('download', filename);
  document.body.appendChild(link); // Required for FF
  link.click();
  document.body.removeChild(link);
}
    // Helper function to get selected nodes
    function getSelectedNodes() {
        const selectedNodes = [];
        nodes.forEach(node => {
            const checkbox = document.getElementById(`node-${node.id}`);
            if (checkbox && checkbox.checked) {
                selectedNodes.push(node);
            }
        });
        return selectedNodes;
    }
        function initialRequest(){


                    times = {{ unique_timestamps|safe }};
                    const nodeData = JSON.parse('{{ node_data|escapejs }}');
;
                    nodes = Object.keys(nodeData);

                    chartData.labels = times

                    nodes.forEach(function (node) {
                        color = getRandomColor()
                        chartData.datasets.push({
                                  label: node,
                                  data: nodeData[node],
                                  borderColor: color, // Generate random color for each node
                                  backgroundColor: color, // Generate random color for each node

                                  fill: false,
                                  {%if smoothing %}
                                  tension: 0.4,
                                  {%endif%}
                                  {%if interpolation %}spanGaps: true,
                                  {%endif%}
                              });
                      lineChart.update();
                    })

                    var currentdate = new Date();
                    var datetime = currentdate.getDate() + "/"
                        + (currentdate.getMonth() + 1) + "/"
                        + currentdate.getFullYear() + " -- "
                        + currentdate.getHours() + ":"
                        + currentdate.getMinutes() + ":"
                        + currentdate.getSeconds();
                    $("#updated").text("Last update: " + datetime)

        }

        function update() {
            $.ajax({
                url: "http://127.0.0.1:8000/metrics/",
                type: "GET",
                dataType: "json",
                success: (response) => {

                    new_nodes = []
                    new_times = []

                    function formatDate(date) {
                        const year = date.getFullYear()
                        const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');

                        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                    }

                    response.forEach(function (element) {
                        if (!nodes.includes(element.address)) {
                            new_nodes.push(element.address)
                            nodes.push(element.address)
                        }
                        formatted_time = formatDate(new Date(element.timestamp))
                        if (new Date(times[times.length-1]).getTime()< new Date(formatDate(new Date(element.timestamp))).getTime()){
                            new_times.push(formatted_time)
                        }
                    })
                    times.concat(new_times)

                    console.log(new_nodes)
                    console.log(new_times)

                    //add new nodes

                    if(new_nodes.length >0)
                    {
                        new_nodes.forEach(function (node){
                            let nulls = Array(times.length).fill(null)
                            console.log(nulls)
                            color = getRandomColor()
                            chartData.datasets.push({
                                  label: node,
                                  borderColor: color, // Generate random color for each node
                                  backgroundColor: color,
                                  data:  nulls,
                                  fill: false,
                                  {%if interpolation %}
                                  cubicInterpolationMode: 'monotone',
                                  tension: 0.4,
                                  {%endif%}
                                  {%if smoothing %}spanGaps: true,
                                  {%endif%}
                              });
                            lineChart.update();

                        })
                        lineChart.update();
                    }
                    //add new times
                    new_times.forEach(function (time) {
                        chartData.labels.push(time)
                    })

                    if(new_times.length >0) {
                        console.log("New Values")
                        nodes.forEach((node, index) => {
                            new_times.forEach(function (time) {
                                var found = false
                                for (let i = response.length-1; i > 0; i--) {
                                    var element = response[i];
                                    if ((formatDate(new Date(element.timestamp)) == time) && element.address == node) {
                                        chartData.datasets[index].data.push(element.{{ metric_name }});
                                        console.log(node)
                                        console.log(index)
                                        found = true
                                        break;
                                    }
                                }
                                if (found === false) {
                                    chartData.datasets[index].data.push(null)  //null
                                }
                            })
                            lineChart.update();
                        })
                    }


                    var currentdate = new Date();
                    var datetime = currentdate.getDate() + "/"
                        + (currentdate.getMonth() + 1) + "/"
                        + currentdate.getFullYear() + " -- "
                        + currentdate.getHours() + ":"
                        + currentdate.getMinutes() + ":"
                        + currentdate.getSeconds();
                    $("#updated").text("Last update: " + datetime)

                    lineChart.ctx.canvas.addEventListener('wheel', lineChart._wheelHandler);


                },
                error: (error) => {
                    console.log(error);
                }

            })
        }


        initialRequest()
      update()
        setInterval(update, 10000);
  }


</script>

<ol class="breadcrumb mb-4">
    <li class="breadcrumb-item active"></li>
</ol>
<div class={% if dark_theme %}
        "card bg-dark text-white mb-4" {% else %} "card mb-4" {% endif %}>
        <div class="card-header">
            <i class="fas fa-chart-area me-1"></i>
            {{ metric_text }}
                 <a style=" float:right; margin-left:10px;"id="exportCSV" type="button" class="btn btn-secondary">Export CSV</a>
                <a style=" float:right; margin-left:10px;"id="exportJSON" type="button" class="btn btn-secondary">Export RAW-JSON</a>
                <a style=" float:right; margin-left:10px;"id="exportImage" type="button" class="btn btn-secondary">Export Image</a>

        </div>
        <div class="card-body">
<canvas id="lineChart"></canvas>

        </div>

        <div id="updated" class="card-footer small text-muted"></div>




{% endblock %}
